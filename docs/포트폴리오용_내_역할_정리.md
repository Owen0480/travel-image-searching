# 포트폴리오용 — "내가 한 부분" 정리

> 팀 프로젝트에서 **본인이 담당한 부분**만 골라서 포트폴리오에 쓸 때 참고용입니다.  
> 아래 [역할 예시]에서 자신이 한 것에 체크하고, [한 줄 요약]·[상세 문장]을 복사해 PPT/이력서에 넣으면 됩니다.

---

## ★ 이미지 업로드 담당자용 (본인 전용)

**"나는 이미지 업로드 부분만 맡았다"** — 그걸 포트폴리오에 이렇게 쓰면 됩니다.

### CLIP은 무슨 기준으로 이미지를 분석해?

CLIP은 **이미지 하나하나에 “라벨”을 붙이는 게 아니라**, 이미지를 **벡터(숫자 나열)** 로 바꾼다. 그 벡터가 “무슨 기준”을 반영하냐면,

- **학습 방식:** CLIP은 **이미지–글(설명문)** 짝으로 학습했다. “이 사진이면 이 글이랑 맞다”를 많이 보면서, **이미지와 글을 같은 공간에 넣어 두는** 방식이다.
- **그래서 나오는 것:** 이미지 한 장 넣으면 → **한 줄기 벡터**가 나온다. 그 벡터는 “이미지가 어떤 내용/분위기/구도인지”를 요약한 것이라고 보면 된다. (색감, 풍경/사물, 구도, 분위기 등이 학습 데이터를 통해 반영됨.)
- **비슷한지 판단:** 두 이미지를 각각 벡터로 바꾼 뒤, **벡터끼리 얼마나 가까운지(코사인 유사도)** 로 “비슷한 이미지”인지 본다. 가까우면 비슷한 장면/분위기라고 보는 거다.

**색감으로 판단하는 거 아니야?**  
색감 **같은 것도** 벡터에 들어간다. 다만 **색감만** 보는 게 아니라, 학습된 **여러 요소**(색감, 구도, 풍경 종류, 사물, 분위기 등)가 **한 벡터에 같이** 반영된다. 그래서 "색감으로 판단한다"고만 하면 좁고, "**색감·구도·풍경·분위기 등이 벡터에 섞여 들어가고**, 그 벡터끼리 가까우면 비슷한 이미지로 본다"가 맞다.

**한 줄:**  
CLIP은 “이 이미지가 뭐예요?”라고 딱 하나로 말해 주는 게 아니라, **이미지를 벡터로 바꿔 주고**, 그 벡터끼리 **가까우면 비슷한 이미지**라고 보는 방식이다. 기준은 “학습할 때 본 이미지–글 짝”에서 나온 **시각적·의미적 유사성**이다.

**"무슨 기준으로 판단·분석했냐?"고 물었을 때 (면접/발표용):**  
*"CLIP을 써서 이미지를 벡터로 바꾸고, 벡터끼리 가까우면 비슷한 이미지로 봅니다. 그래서 '이 기준 하나로 판단했다'기보다는, CLIP이 학습한 시각·의미 유사성이 벡터에 반영되고, 그 벡터 거리(코사인 유사도)로 비슷한지 판단합니다."*  
→ 말할 때는 **"CLIP으로 이미지를 벡터로 바꾸고, 벡터가 가까우면 비슷한 이미지로 본다"**만 해도 충분함.

### 색감·구도·풍경·분위기 — 이걸 "어떻게" 찾는지

**우리가 규칙으로 정한 기준이 아니다.** CLIP은 **이미지–글(설명) 짝**을 엄청 많이 보면서 학습했다. "이 사진에는 이 글이 맞다 / 저 글이 아니다"를 반복해서 맞추다 보니, **같은 의미·비슷한 느낌의 이미지**끼리는 벡터가 가깝게, 다른 느낌이면 멀게 나오도록 **네트워크가 스스로** 배운 거다.

그래서 "색감은 1번 차원, 구도는 2번 차원"처럼 **우리가 정한 기준**이 아니라, **학습 데이터 안에 있던 정보**(색감·풍경·분위기 등을 설명한 글들)가 벡터에 **스스로 녹아 들어간 것**이다. "어떻게 찾냐"에 대한 답은 **"사람이 규칙을 만든 게 아니라, 학습할 때 이미지–글 짝에서 모델이 스스로 유사한 걸 가깝게 배운 것"**이라고 하면 된다.

### "우리 데이터에서 무슨 기준으로 판단했어?"

**둘로 나눠서 생각하면 된다.**

| 구분 | 누가 정한 거냐 | 뭔 기준이냐 |
|------|----------------|------------|
| **뭐가 비슷한지 (벡터 유사도)** | **CLIP** (이미 학습된 모델) | CLIP이 **자기 학습 데이터**(공개 이미지–글 짝)로 미리 배운 것. **우리 여행 데이터로 기준을 만든 게 아님.** 우리 이미지는 그냥 CLIP에 넣어서 벡터만 뽑고, 그 벡터끼리 가까운지 본다. |
| **얼마나 가까워야 매칭으로 볼지** | **우리** (프로젝트) | **유사도 0.6 임계값.** 코드에서 `score > 0.6`일 때만 "매칭됐다"고 하고, 그 아래면 "유사한 여행지를 찾지 못했습니다"로 처리함. |

정리하면:  
- **CLIP** → 벡터화·유사도는 CLIP이 **미리 배운 기준**으로 한다. 우리 데이터가 그 기준을 "만든" 게 아니다.  
- **우리** → 우리가 **우리 데이터(서비스)에서** 정한 기준은 **"유사도 0.6 넘을 때만 매칭"** 하나다.

### 쉽게 설명할 때 (한꺼번에 말할 문장)

**초간단 (한 문장):**  
*"CLIP으로 이미지를 벡터로 바꾸고, 벡터가 가까우면 비슷한 이미지로 봅니다. 우리는 유사도 0.6 넘을 때만 매칭으로 씁니다."*

**조금 더 (2~3문장):**  
*"이미지 추천은 CLIP을 씁니다. CLIP이 이미지를 벡터로 바꿔 주고, 벡터끼리 가까우면 색감·풍경·분위기가 비슷한 이미지로 봅니다. CNN 따로 안 쓰고, CLIP이 이미지 인코딩까지 다 해 주고, 우리는 유사도 0.6 넘는 것만 매칭으로 보여줍니다."*

**CNN 물었을 때:**  
*"CNN 따로 쓸 필요 없어요. CLIP 안에 이미지 인코더가 들어 있어서, 이미지 → 벡터까지 CLIP 한 번에 처리합니다."*

**"CNN이랑 뭐가 달라? CNN은 인코더가 없어서?"**  
CNN도 **이미지 인코더로 쓸 수 있다.** CNN 자체가 이미지에서 특징을 뽑는 모델이다.  
차이는 "CNN에는 인코더가 없어서"가 아니라, **"CLIP을 쓰면 이미 이미지 인코더가 CLIP 안에 들어 있어서, 우리가 CNN을 따로 설계하거나 붙일 필요가 없다"**는 거다.  
즉, CLIP = 이미지 인코더 + (텍스트와 같은 벡터 공간에서 비교 가능). 그래서 CNN을 **별도로** 쓸 필요가 없는 것.

**"AI로 돌려도 되는데 왜 이렇게 했나요?" / "왜 CLIP 썼나요?"**  
*"직접 CNN 등으로 학습시키면 GPU·학습 시간 부담이 커서, 이미 이미지–텍스트로 학습된 **CLIP**을 쓰기로 했습니다. 이미지를 벡터로 바꿔서 유사 이미지를 찾을 수 있고, DB 이미지는 **서버 기동 시 미리 벡터화해 두어서** 요청 시에는 사용자 이미지 한 장만 인코딩하면 돼서 응답이 빨라집니다."*  
→ **주의:** "CNN 쓰면 GPU 써서 느리니까 CLIP 썼다"라고 하면, CLIP도 GPU 쓰고 무거울 수 있어서 오해받을 수 있음. **"직접 학습은 부담이 커서 사전학습된 CLIP을 썼고, DB 이미지 사전 벡터화로 응답 속도를 줄였다"**라고 말하는 게 안전함.

**"유사 이미지는 어떻게 찾아요? 무슨 기준이에요?" (이어서 물었을 때)**  
*"유사 이미지는 **벡터 거리**로 찾습니다. 사용자 이미지 한 장을 CLIP으로 벡터로 바꾸고, 미리 벡터화해 둔 DB 이미지 벡터들과 **코사인 유사도**를 구해서, 숫자가 클수록 비슷한 이미지로 봅니다. **기준**은 두 가지인데, (1) ‘뭐가 비슷한지’는 CLIP이 이미지–텍스트로 학습할 때 스스로 배운 시각·의미 유사성이라서 우리가 따로 정한 게 없고, (2) ‘얼마나 가까워야 매칭으로 볼지’는 우리가 **유사도 0.6**을 임계값으로 정해서, 0.6 넘을 때만 유사 이미지로 보여줍니다."*  
→ **한 줄:** "벡터끼리 코사인 유사도로 찾고, 0.6 넘는 것만 매칭으로 씁니다."

---

### images 폴더 / tour.csv / place.csv — 쉽게 정리

| 뭔가 | 하는 일 (한 줄) |
|------|------------------|
| **images 폴더** | **여행지 사진 파일**이 들어 있는 곳. jpg 파일들이 그대로 들어 있음. 사용자가 올린 사진과 "비슷한지" 비교할 **기준 사진들**. |
| **tour.csv** | **"이 사진 파일은 어느 장소 건가?"** 적어 둔 목록. 예: `f00033801003p0001.jpg` → 장소 번호 2305200004. (파일 이름 ↔ 장소 ID 연결) |
| **place.csv** | **"이 장소 번호는 어떤 곳인가?"** 적어 둔 목록. 예: 장소 번호 2307260003 → 이름 "짱꼬집", 주소 "서울 송파구 백제고분로7길 56" 등. |

**흐름:**  
사진 파일(`images/`) → tour.csv로 "이 사진 = 몇 번 장소" 찾고 → place.csv로 "그 장소 = 이름·주소" 찾아서 → 사용자에게 "이 여행지예요, 여기 주소예요" 로 보여 줌.

---

### "코드에 이미지가 올라와 있다"는 말이 뭔 뜻이야?

**말하는 사람 의도:** 프로젝트(저장소/코드베이스) 안에 **비교용 기준 이미지**가 이미 들어가 있다는 뜻이다.

- **어디에:** `backend-fastapi/images/` 폴더에 jpg 파일들이 있음 (예: f00001102099p0002.jpg 등).  
- **역할:** 사용자가 올린 사진과 **이미지들**을 CLIP으로 비교해서, 비슷한 여행지(장소)를 찾는 **기준 데이터**.
- **정리:**  
  - **사용자 업로드 이미지** = 방금 고른 사진 1장 (요청할 때마다 들어옴).  
  - **코드에 올라와 있는 이미지** = `images/` 폴더에 미리 넣어 둔 **여행지 사진들**. 서버가 뜰 때 이걸 한 번 임베딩해 두고, 사용자 사진과 유사도 비교할 때 씀.

그래서 "코드에 이미지가 올라와 있다" = "비교 대상 여행지 사진이 프로젝트에 이미 포함돼 있다"고 이해하면 됨.

### "이미지는 DB에 두는 게 아니야?" (지금 폴더에 두는 것)

**맞아요. 지금은 기준 이미지를 프로젝트 폴더(`images/`)에 두고 있고, 장소 정보는 CSV로 되어 있어서 "DB에 두는 게 낫지 않나?"라고 생각한 거 맞습니다.**

- **현재 구조:**  
  - 이미지 파일 → `backend-fastapi/images/` 폴더  
  - 장소 메타(이미지–장소 매핑) → `data/tour.csv`, `place.csv`  
  - 서버 기동 시 폴더에서 jpg 목록 읽어서 임베딩 후 비교에 사용

- **DB에 두는 게 나은 이유:**  
  - **관리**: 이미지 추가/삭제/수정이 DB(또는 DB + 스토리지)로 한 곳에서 관리됨  
  - **배포/확장**: 서버가 여러 대여도 같은 DB를 보면 됨. 폴더는 서버마다 동기화해야 함  
  - **백업·버전**: DB/스토리지 기준으로 백업·복구가 명확함  
  - **일관성**: 장소 메타도 DB에 있으면 CSV와 폴더 이중 관리가 사라짐  

- **실제로 하려면:**  
  - 이미지 **바이너리**를 DB(BLOB)에 넣거나,  
  - 이미지 파일은 **스토리지(S3 등)**에 두고 **경로만 DB**에 넣는 방식이 일반적.  
  - 서버 기동 시(또는 주기적으로) **DB에서 이미지 목록/경로 읽어서** 임베딩하면 됨.

### "스토리지"가 뭐야?

**스토리지(Storage)** = **파일(이미지 등)을 보관하는 곳**이라고 보면 된다. "저장소"랑 같은 말이다.

- **지금 우리**: 이미지 파일이 **프로젝트 폴더(`images/`)** 안에 있음. → 이 폴더도 일종의 "스토리지"다. 다만 서버 컴퓨터 안에 있어서, 서버가 여러 대면 폴더를 각각 맞춰 줘야 함.
- **스토리지를 따로 둔다** = 이미지 파일을 **"파일만 넣어두는 전용 공간"**에 두고, DB에는 **"그 파일이 어디 있는지"(경로, URL)**만 적어 두는 방식이다.  
  예: **AWS S3**, **네이버 클라우드**, **서버 디스크의 특정 경로** 등.  
  DB = "몇 번 장소에 어떤 이미지가 있다"는 **목록(메타)**만 관리, 실제 파일 = 스토리지에 보관.

**비유:**  
- **DB** = 도서관의 "책 목록"(장소–이미지 매핑, 경로 등).  
- **스토리지** = 책(이미지 파일)을 실제로 쌓아 두는 **창고**. 목록에는 "창고 3번 칸"처럼 **위치(경로)**만 적어 둠.

**정리:**  
스토리지 = **이미지 파일을 보관하는 곳**(지금의 `images/` 폴더 역할을 하는 곳). DB에 이미지를 넣을 때 "파일은 스토리지에 두고, 경로만 DB에 넣는다" = **파일 보관함(스토리지)**과 **목록(DB)**을 나눠서 쓰는 방식이다.

### "파일은 서버/스토리지에 두고 경로만 DB" vs "내 컴퓨터에 넣는 거" — 뭐가 달라?

**저장 방식 두 가지:**

| 방식 | 이미지 파일 위치 | DB에 넣는 것 | "내 컴퓨터"랑 관계 |
|------|------------------|--------------|---------------------|
| **A. DB에 파일(BLOB) 넣기** | DB 안 (바이너리로 저장) | 파일 자체 | 파일이 DB에 있으니까 "내 컴퓨터 폴더"에 안 둬도 됨. DB만 접속하면 됨. |
| **B. 파일은 서버/스토리지, 경로만 DB** | **서버(내 컴퓨터) 폴더** 또는 **별도 스토리지(S3 등)** | **경로 또는 URL** | 아래 참고. |

**"서버/스토리지에 둔다"가 두 가지 의미:**

1. **같은 서버(내 컴퓨터) 폴더에 둔다**  
   - 이미지 파일을 **지금처럼** 서버 돌리는 그 컴퓨터의 **어떤 폴더**(예: `C:\app\uploads\images`)에 둠.  
   - DB에는 **그 경로만** 넣음 (예: `C:\app\uploads\images\photo1.jpg` 또는 `/uploads/images/photo1.jpg`).  
   - **내 컴퓨터에 넣는 거랑 같다.** 차이는 **"어떤 장소에 어떤 이미지가 있다"**를 CSV가 아니라 **DB 테이블**에서 관리한다는 것.  
   - 다른 컴퓨터에서 서버 돌리면, 그쪽에도 **같은 폴더 구조로 파일을 복사**해 둬야 할 수 있음 (파일은 여전히 "그 컴퓨터"에 있어야 함).

2. **별도 스토리지(S3, 클라우드 등)에 둔다**  
   - 이미지 파일을 **우리 서버(내 컴퓨터)가 아닌** 전용 공간(AWS S3, 네이버 클라우드 등)에 둠.  
   - DB에는 **URL만** 넣음 (예: `https://bucket.s3.../photo1.jpg`).  
   - **내 컴퓨터에는 파일이 없다.** 어떤 컴퓨터에서 서버를 돌려도 **DB에서 URL만 읽어서** 그 주소로 접근하면 됨. 그래서 **각 컴퓨터에 파일을 다운받거나 복사할 필요가 없음.**

**한 줄:**  
- **"파일은 서버에 두고 경로만 DB"**에서 서버 = **내 컴퓨터(서버) 폴더**면 → **내 컴퓨터에 넣는 거랑 같고**, 목록만 DB로 옮기는 것.  
- **스토리지(S3 등)**에 두면 → 파일은 **내 컴퓨터가 아닌 클라우드**에 있어서, 다른 컴퓨터에서도 **경로(URL)만 있으면** 접근 가능.

**포트폴리오/면접에서 말할 때:**  
*"현재는 기준 이미지를 프로젝트 폴더에 두고 있는데, 저는 **기준 이미지를 DB(또는 DB 메타 + 스토리지)에 두는 게 관리와 확장성 측면에서 낫다고 생각했습니다.** 실제로 적용하려면 이미지 경로를 DB에 두고, 서버 기동 시 DB에서 읽어서 임베딩하도록 바꾸면 됩니다."*  
→ 이렇게 하면 "그냥 받아만 쓴 게 아니라 **설계 개선까지 고민했다**"로 어필할 수 있음.

### 포트폴리오용으로 만든다면 어떤 걸 추천해?

**추천 순서:**

| 순위 | 방식 | 이유 (포트폴리오 관점) |
|------|------|------------------------|
| **1** | **DB에 경로만 넣기 + 파일은 서버 폴더** | 구현 난이도 낮고, "목록(메타)은 DB, 파일은 서버"로 **설계를 나눠 본 경험**을 말하기 좋음. S3 없이도 DB 전환만 보여줄 수 있음. |
| **2** | **DB에 이미지 BLOB로 넣기** | "한 군데(DB)에서 다 관리"로 **말하기가 쉽고**, 다른 컴퓨터에서 DB만 접속하면 되니까 **데모·공유**하기 좋음. 이미지 수가 많지 않으면 포트폴리오 규모에선 부담 적음. |
| **3** | **S3(또는 클라우드 스토리지) + URL만 DB** | **클라우드·인프라** 역량을 강조할 때만 추천. AWS 계정·설정 필요하고, 포트폴리오에서 "이미지 담당"보다 "인프라까지 손댔다"가 메인이 됨. |

**한 줄:**  
포트폴리오용이면 **1번(경로만 DB + 서버 폴더)** 또는 **2번(DB BLOB)** 중 하나로 가져가고, "나중에 트래픽 늘면 S3로 분리할 수 있다"고만 말해도 됨.

### "굳이 우리 데이터로 해야 해? 외부 데이터·AI가 찾게 하면 더 쉽지 않아?"

**아니요, 꼭 우리 데이터일 필요는 없다.** 외부 데이터·API를 쓰면 **이미지·CSV·DB를 우리가 관리하지 않아도** 되고, 구현이 더 단순해질 수 있다.

| 구분 | 우리 데이터 (지금 방식) | 외부 데이터·API |
|------|-------------------------|-----------------|
| **장점** | 추천 대상·품질을 **우리가 정함**. CLIP 유사도로 **시각적으로 비슷한** 이미지를 직접 찾음. 데이터·파이프라인 설계 경험 어필 가능. | **데이터 관리 부담이 적음.** 이미지 폴더·CSV·DB 유지보수 없음. API 호출만 하면 됨. |
| **단점** | 이미지·메타를 **우리가 준비·관리**해야 함. | **비용·호출 제한**(API 키, 할당량). 결과가 **외부 서비스에 종속**. "이미지 업로드 → 비슷한 장소"를 **한 번에** 해주는 API가 많지 않아서, 보통은 "이미지 → AI가 키워드 추출 → 그 키워드로 장소 검색" 식으로 단계가 나뉨. |
| **적합한 경우** | 추천 대상(여행지 풀)을 **우리가 정하고**, **시각적 유사도**(CLIP)로 매칭하고 싶을 때. | "장소 검색·정보만 외부에서 가져오면 된다"일 때. |

**외부로 하려면 보통:**  
- 사용자 이미지 → **비전 API**(Gemini Vision 등)로 "어떤 장소/분위기다" **키워드·설명** 추출 → 그 키워드로 **네이버/구글 Places API** 등에서 장소 검색.  
- 이렇게 하면 **우리 이미지 DB는 필요 없고**, 대신 "시각적 유사도(CLIP)"가 아니라 **"AI가 설명한 키워드 기반 검색"**에 가깝다.

**포트폴리오 관점:**  
- **우리 데이터**: "데이터 설계·CLIP 파이프라인·RAG·임베딩 관리"까지 **끝까지 설계했다**는 걸 보여줄 수 있음.  
- **외부 데이터·API만**: "외부 API 연동·비전·검색 플로우"를 보여줄 수 있음. **더 쉽고 간편**할 수 있지만, "우리가 가진 이미지로 유사도를 직접 구했다"는 스토리는 약해짐.  
- **굳이 우리 데이터에서 해야 하는 건 아니다.** 다만 "우리 데이터 + CLIP"이면 **설계·파이프라인 역량**을, "외부 API만"이면 **연동·단순화**를 강조하는 차이다.

### DB에 둘 때 무엇부터 해야 해?

순서만 따라가면 됨.

| 순서 | 할 일 | 설명 |
|------|--------|------|
| **1** | **저장 방식 정하기** | 이미지 **파일 자체**를 DB에 넣을지(BLOB), **파일은 서버/스토리지에 두고 경로만 DB**에 넣을지 정함. 보통은 경로만 DB가 관리하기 쉬움. |
| **2** | **테이블 설계** | 예: `place`(장소 번호, 이름, 주소), `place_photo`(장소 번호, 이미지 경로 또는 BLOB). tour.csv + place.csv 내용을 DB 테이블로 옮길 구조 생각. |
| **3** | **테이블 만들기** | MariaDB에 `place`, `place_photo` 같은 테이블 생성 (Spring이 쓰는 DB에 추가하거나, FastAPI가 읽을 DB에 생성). |
| **4** | **데이터 넣기** | 지금 `images/` 폴더 파일이랑 tour.csv, place.csv 내용을 읽어서 DB에 INSERT. (한 번 돌리는 이전 스크립트 만들면 됨.) |
| **5** | **코드 수정** | FastAPI 쪽에서 **폴더 + CSV 대신 DB에서** 장소·이미지 목록 가져오도록 수정. 서버 기동 시 DB 조회 → 이미지 읽어서 임베딩. |
| **6** | **이미지 제공** | DB에 경로만 넣었다면, 그 경로에 있는 파일을 FastAPI에서 URL로 줄 수 있게 정적 경로 또는 API 하나 둠. (지금 `/images/파일명` 쓰는 것처럼.) |

**한 줄 요약:** 1) 어떻게 저장할지 정하고 → 2) 테이블 설계·생성 → 3) CSV+폴더 데이터 DB에 넣고 → 4) 코드는 DB에서 읽도록 바꾸면 됨.

### DB로 바꿨을 때 — 뭐가 바뀌고 뭐는 그대로야?

**임베딩은 그대로 한다.** 안 없어짐. 바뀌는 건 **데이터를 어디서 가져오느냐**뿐임.

| 구분 | 지금 (폴더+CSV) | DB로 바꾼 뒤 |
|------|------------------|--------------|
| **기준 이미지 목록** | `images/` 폴더에서 `os.listdir`로 파일 목록 | DB에서 이미지 목록(또는 경로) **조회** |
| **기준 이미지 바이트** | 폴더 경로로 파일 열어서 읽기 | DB에서 **BLOB** 읽거나, DB에 넣은 **경로**로 파일 읽기 |
| **임베딩 (CLIP)** | 서버 기동 시 폴더 이미지들 → `model.encode()` → `db_features`에 저장 | **똑같이** 서버 기동 시 이미지들(이번엔 DB에서 가져온) → `model.encode()` → `db_features`에 저장. **로직 동일.** |
| **장소 정보 (이름, 주소)** | `_get_place_info(file_name)` → **merged_df(CSV)**에서 파일명으로 검색 | `_get_place_info(id 또는 file_name)` → **DB 쿼리**로 장소 정보 조회 |
| **Chroma 장소 문서** | `merged_df` 기반으로 청크 만들어 Chroma에 저장 | **DB에서** 장소 목록 가져와서 청크 만들어 Chroma에 저장 (데이터 소스만 DB로 변경) |

**그대로인 것 (안 바꿔도 됨):**

- **임베딩** — 서버 뜰 때 기준 이미지 임베딩, 사용자 이미지 임베딩, 코사인 유사도, TopK, 임계값 0.6 … 전부 **그대로**.
- **사용자 요청 흐름** — 사용자 사진 받음 → CLIP 인코딩 → 유사도 계산 → Top3 → 장소 정보 붙임 → 가이드 생성. **흐름 동일.** 장소 정보만 CSV 대신 DB에서 가져오게 바꾸면 됨.
- **Gemini 가이드, Chroma RAG** — 로직은 그대로. 넣어 주는 **데이터 소스**만 CSV/폴더 → DB로 바꾸면 됨.

**한 줄:**  
데이터 **출처**만 폴더+CSV → DB로 바꾸는 거고, **임베딩·유사도·가이드 생성 같은 처리 로직은 그대로**다.

---

### 담당 범위 (내가 한 것만 쓸 때)

| 구분 | 포함하면 좋은 내용 |
|------|---------------------|
| **프론트** | 사진 선택(input type="file", accept="image/*"), 미리보기(URL.createObjectURL), 취향 입력란, **FormData로 file + preference 전송**, **multipart/form-data**로 Spring API 호출, **로딩 오버레이**(분석 중 UI), **응답 분기**(results 배열 vs 단일 객체), **결과 카드**(유사도 %, 주소, 가이드 문장, 이미지), **상세 보기 → 네이버 지도** 새 창, **에러 처리**(연결 실패·매칭 없음 시 메시지) |
| **Spring (본인이 했다면)** | `/api/v1/recommend/analyze` — **MultipartFile** + preference 받아서 FastAPI로 전달, 응답 그대로 프론트에 반환 |

- **FastAPI(CLIP·RAG·Gemini)** 는 팀원 담당이면 "백엔드 API와 연동해" 정도만 쓰고, 본인은 **요청 보내고 결과 받아서 화면에 붙인 부분**을 강조하면 됨.

### 한 줄 요약 (복사해서 쓰기)

- **프론트만:**  
  *"이미지 기반 여행지 추천 **업로드 플로우**를 담당해, 사진 선택·미리보기·FormData 전송·로딩 UI·결과 카드·네이버 지도 연동까지 구현했습니다."*
- **프론트 + Spring API:**  
  *"이미지 업로드 **UI와 Spring API**를 담당해, Multipart 수신·FastAPI 연동·프론트 FormData 전송·결과 표시·지도 연동까지 한 흐름으로 구현했습니다."*

### 상세 문장 (2~3문장, 이력서/PPT용)

*"팀 프로젝트에서 **이미지 업로드·추천 결과 표시**를 전담했습니다. 사용자 사진 선택, 취향 입력, **FormData로 multipart 전송** 후 Spring → FastAPI 추천 API와 연동했고, 로딩 오버레이·Top3 결과 카드(유사도, 가이드 문장)·**네이버 지도 상세 보기** 연동·에러/빈결과 메시지 처리까지 구현했습니다."*

### 이 부분만으로 약한가?

- **아니요.**  
  - 한 화면이지만 **파일 업로드(multipart)·비동기 API 연동·로딩·에러·외부 서비스(지도) 연동**이 한 흐름으로 들어가 있어서, "단순 CRUD"보다 기술 밀도가 높습니다.
- 포트폴리오에는 **"이미지 업로드 담당"**이라고 명시하고, 위 **한 줄 요약**이나 **상세 문장**을 그대로 넣으면 됩니다.

### "이미지 부분은 AI 돌리면 되는 거 아니야?" 지적에 대응하기

누가 **"이미지 부분은 AI 서비스 돌리면 되잖아, 그걸 포트폴리오로 할 수 있냐"**라고 하면 아래처럼 구체적으로 말하면 됩니다.

- **오해**: "이미지 분석 = AI API 한 번 호출"로 보일 수 있음.  
- **실제로 한 일**:  
  - **AI 모델(CLIP·Gemini)을 돌리는 건 백엔드(FastAPI)** 쪽이고,  
  - **내가 한 건**  
    - 프론트에서 **파일·취향을 어떤 형식으로 보낼지**(FormData, multipart),  
    - **어떤 API로, 어떤 헤더로** 호출할지,  
    - **응답을 어떻게 파싱**할지(results 배열 vs 단일 객체 등),  
    - **로딩 중/에러/매칭 없음**을 어떻게 처리할지,  
    - **결과를 어떤 UI로 보여주고**, **지도 링크는 어떻게 열지**  
  까지 **설계하고 코드로 구현한 것**입니다.  
  즉 "AI 한 번 호출"이 아니라 **업로드 플로우·API 연동·상태 처리·UX**를 구현한 것입니다.

**면접/발표에서 한마디로 말할 때 (외울 만한 문장):**

> "이미지 분석 자체는 백엔드 AI 서비스가 하고, 저는 **그 API를 어떻게 호출하고, 응답을 어떻게 파싱해서 화면에 붙일지**를 구현했습니다. multipart 파일 전송, 로딩·에러 처리, 결과 카드 UI, 네이버 지도 연동까지 전부 직접 작성했습니다. AI 호출 한 줄이 아니라 **연동·상태·UX까지 포함한 플로우**를 담당한 거라고 말씀드리면 됩니다."

**코드로 증명하고 싶을 때:**  
해당 화면/API의 **어디를 내가 짰는지**(예: FormData 조립, 응답 분기, 로딩 state)를 미리 짚어두고, "이 부분 코드 보여줘" / "이거 구현해줘" 하면 그때그때 코드 작성해 줄 수 있음.

### 따로 분석·파인튜닝 하면 더 좋을까?

- **결론: 분석 추가하면 좋고, 파인튜닝은 목표에 따라.**

| 하고 싶은 것 | 포트폴리오 효과 | 부담 | 추천 |
|--------------|-----------------|------|------|
| **파인튜닝(CLIP 등)** | "이미지 모델까지 손댔다" → ML/AI 포지션에 강함 | 데이터·GPU·시간 많이 듦 | ML 쪽 지원할 때만 권장 |
| **유사도/임계값 분석** | "결과 품질을 숫자로 검증했다" → 설계·분석 능력 어필 | 적음 (기존 API/로그만 있으면 됨) | **우선 추천** |
| **간단 실험(임계값 0.5 vs 0.6 vs 0.7)** | "실험 설계·비교를 해봤다" | 적음 | **우선 추천** |
| **임베딩 시각화(t-SNE/UMAP)** | "벡터 공간을 이해하고 시각화했다" | 중간 (스크립트 한두 개) | 여유 있으면 |

**추천 흐름**

1. **지금 역할(업로드·연동)은 그대로 강조**하고,
2. **추가로** 아래 중 하나만 해도 포트폴리오 문장이 확실히 달라짐:
   - **유사도 분포 정리**: 업로드 이미지 vs DB 이미지 유사도가 어떻게 나오는지, **왜 임계값 0.6을 쓰는지**를 짧은 분석(표·그래프)으로 정리.
   - **임계값 비교**: 0.5 / 0.6 / 0.7일 때 "매칭 개수·품질" 차이를 샘플 몇 개로라도 비교해 본 뒤, "임계값 선정 근거를 실험으로 확인했다"고 쓰기.
3. **파인튜닝**은 "ML/인공지능 직무" 지원할 때 **추가 포인트**로만 고려.  
   - 하려면: (이미지, 텍스트/라벨) 데이터 준비 → CLIP 계열 모델 파인튜닝(또는 LoRA 등 경량화) → 유사도 성능 비교.  
   - 시간·리소스 여유 있을 때만.

**포트폴리오에 쓸 때 예시 문장 (분석 추가 시)**

- *"이미지 업로드·결과 표시를 담당했고, **추가로 추천 API의 유사도 분포를 분석해 임계값(0.6) 선정 근거를 정리**했습니다."*
- *"업로드 플로우 구현 후 **임계값(0.5/0.6/0.7)에 따른 매칭률을 비교하는 간단 실험**을 진행해, 서비스에 반영된 0.6 선택 이유를 정리했습니다."*

이렇게 쓰면 "AI 돌리기만 한 게 아니라, **결과를 분석·검증한 경험**이 있다"로 어필할 수 있음.

### "GPU·시간 부담 때문에 CLIP 썼다" / "이미지 분석 시간 줄이려고" 말할 때

**주의:** "GPU·시간 부담이 커서 CLIP을 썼다"라고만 하면, "CLIP 쓰면 부담이 더 커지지 않나?"라고 오해받을 수 있음.  
의도는 보통 다음 둘이다.

- **파인튜닝은 GPU·학습 시간 부담이 커서 하지 않고**, 대신 **사전학습된 CLIP**을 그대로 사용했다.
- **이미지 분석(임베딩 추출)**이 요청마다 하면 느리니까, **DB 이미지는 서버 기동 시 미리 임베딩해 두어(캐싱)** 응답 시간을 줄였다.

**그래서 이렇게 말하면 됨 (복사해서 쓰기):**

- *"파인튜닝은 GPU와 학습 시간 부담이 커서 진행하지 않고, **사전학습된 CLIP 모델**을 그대로 사용해 이미지 유사도를 구했습니다. 이미지 분석(임베딩)이 요청 시마다 돌면 시간이 오래 걸리기 때문에, **DB에 있는 이미지는 서버 기동 시 한 번만 임베딩해 두고 재사용**해 응답 속도를 줄였습니다."*

**한 줄로:**  
*"GPU·시간 부담 때문에 파인튜닝 대신 CLIP 사전학습 모델을 사용했고, 이미지 분석 시간을 줄이기 위해 DB 이미지는 미리 임베딩해 두었습니다."*

이렇게 하면 "CLIP을 썼다"가 **선택 이유(파인튜닝 대신)**와 **속도 개선(사전 임베딩)**까지 한 번에 설명됨.

---

## 1. 이 프로젝트가 "약하다"고 느껴질 때

- **실제로는** 풀스택 + AI 파이프라인(CLIP, RAG, LLM)이 들어간 중규모 프로젝트입니다.
- 포트폴리오에서 "약해 보이는" 이유는 보통 **내가 한 부분이 구체적으로 드러나지 않아서**입니다.
- 그래서 **"무슨 기능을 누가 했는지"를 명확히 쓰는 것**이 중요합니다.

---

## 2. 프로젝트 규모 (강조할 때 참고)

| 구분 | 내용 |
|------|------|
| **Frontend** | React 18, Vite, React Router, Axios, 이미지 검색·채팅·여행스타일·마이페이지·OAuth 콜백 |
| **Backend (Spring)** | Spring Boot 3, OAuth2·JWT·Refresh(Redis), Recommend/Chat/TravelStyle/User/Conversation API, WebClient로 FastAPI 연동 |
| **Backend (FastAPI)** | CLIP 이미지 유사도, ChromaDB RAG, Gemini 가이드/채팅, LangGraph 기반 플로우, 여행 스타일 분석 |
| **기술 키워드** | CLIP, ChromaDB, RAG, Gemini, LangGraph, JWT, Redis, OAuth2, Multi-backend 연동 |

---

## 3. 역할 예시 — "내가 한 부분" 체크용

아래에서 **본인이 실제로 한 일**에 ✓ 표시하고, 해당 행의 [한 줄 요약]을 포트폴리오에 사용하세요.

### Frontend

| 담당 가능 영역 | 한 줄 요약 (포트폴리오용) |
|----------------|---------------------------|
| □ 이미지 검색 페이지 (업로드, 취향 입력, 결과 카드, 상세보기) | "이미지 기반 여행지 추천 UI 전담 — 파일 업로드·로딩·Top3 카드·네이버 지도 연동까지 구현" |
| □ 채팅 페이지 (iframe/Conversation UI, 메시지 전송·표시) | "여행 AI 채팅 화면 구현 — Spring/FastAPI 연동 및 대화 저장 플로우 연동" |
| □ 여행 스타일 분석 페이지 (관심사 선택, 분석 결과 팝업) | "여행 스타일 분석 화면 구현 — 관심사 선택 UI와 분석 결과 표시 담당" |
| □ 로그인·OAuth 콜백·라우팅 | "Google OAuth 로그인 플로우 및 JWT 기반 라우팅(보호 구간 리다이렉트) 구현" |
| □ 공통 레이아웃·Navbar·마이페이지 | "공통 레이아웃·네비게이션·마이페이지 UI 구현" |
| □ Axios 인터셉터 (토큰·Refresh) | "Axios 인터셉터로 Access/Refresh 토큰 자동 부착 및 401 시 갱신 처리 구현" |

### Backend (Spring Boot)

| 담당 가능 영역 | 한 줄 요약 (포트폴리오용) |
|----------------|---------------------------|
| □ OAuth2·JWT·Refresh·Redis | "Google OAuth2 + JWT·Refresh Token 도입 및 Redis 저장, 인증/인가 전담" |
| □ Recommend API (이미지·취향 → FastAPI 프록시) | "이미지 추천 API 게이트웨이 담당 — Multipart·WebClient로 FastAPI 연동" |
| □ Travel Chat API (채팅 프록시·thread_id) | "여행 채팅 API 연동 — Spring ↔ FastAPI 프록시 및 대화 스레드 관리" |
| □ Travel Style API (분석 요청·결과 저장) | "여행 스타일 분석 API·DB 저장 설계 및 구현" |
| □ SavedConversation (저장·조회) | "대화 저장·목록 조회 API 및 엔티티 설계 구현" |
| □ User·마이페이지 API | "사용자 정보·마이페이지 API 및 OAuth2 사용자 매핑 구현" |
| □ Security·CORS·예외 처리 | "Spring Security 설정, CORS·예외 처리(GlobalExceptionHandler) 설계" |

### Backend (FastAPI / AI)

| 담당 가능 영역 | 한 줄 요약 (포트폴리오용) |
|----------------|---------------------------|
| □ 이미지 추천 파이프라인 (CLIP + 유사도 TopK) | "CLIP 기반 이미지 유사도 검색 파이프라인 구현 — DB 이미지 사전 임베딩 캐싱 포함" |
| □ ChromaDB RAG·장소 문서 인덱싱 | "ChromaDB 벡터 DB 구축 및 장소 문서 청크 인덱싱·검색 설계" |
| □ Gemini 가이드 생성 (취향 반영) | "취향 키워드 기반 RAG 검색 후 Gemini로 여행지 가이드 문장 생성 구현" |
| □ Travel Chat (LangGraph 등) | "LangGraph 기반 여행 상담 챗봇 플로우 설계·구현" |
| □ 여행 스타일 분석 (관심사 → 타입 매칭) | "관심사 입력 기반 여행 스타일 분석 API 및 타입 매칭 로직 구현" |
| □ FastAPI 라우터·스키마·에러 처리 | "FastAPI v1 라우터 구조·Pydantic 스키마·에러 응답 설계" |

### 기타

| 담당 가능 영역 | 한 줄 요약 (포트폴리오용) |
|----------------|---------------------------|
| □ DB 설계 (MariaDB·엔티티·ERD) | "MariaDB 스키마 및 JPA 엔티티 설계, ERD 작성" |
| □ 배포·docker-compose·환경 분리 | "로컬/배포 환경 분리 및 Docker Compose 구성" |
| □ 통합 테스트 시나리오·문서화 | "통합 테스트 시나리오 작성 및 PPT 정리" |

---

## 4. 포트폴리오에 쓸 "상세 문장" 예시 (2~3문장)

**예시 1 — 프론트 중심**  
"이미지 기반 여행지 추천 화면을 전담해, 사진 업로드·취향 입력부터 Spring/FastAPI 연동·로딩 처리·Top3 카드 UI·네이버 지도 상세 보기까지 구현했습니다. 추가로 Axios 인터셉터로 JWT·Refresh 토큰 자동 부착 및 401 시 재발급 플로우를 적용했습니다."

**예시 2 — 백엔드(Spring) 중심**  
"Spring Boot에서 Google OAuth2·JWT·Refresh Token을 도입하고 Redis에 Refresh 토큰을 저장해 인증/인가를 구현했습니다. 이미지 추천·채팅·여행 스타일 API를 WebClient로 FastAPI와 연동하는 게이트웨이 역할을 담당했습니다."

**예시 3 — AI(FastAPI) 중심**  
"FastAPI에서 CLIP으로 이미지 유사도를 구하고, ChromaDB로 장소 문서 RAG를 구성한 뒤 Gemini로 취향 반영 가이드 문장을 생성하는 파이프라인을 구현했습니다. DB 이미지 임베딩은 서버 기동 시 미리 계산해 응답 속도를 개선했습니다."

---

## 5. PPT/이력서에 넣을 때 팁

1. **제목**: "여행·숙박 추천 AI 서비스 (이미지·RAG·채팅)" 처럼 **키워드**를 넣는다.
2. **내 역할**: "본인 담당: ○○ 페이지 전담, △△ API 설계·구현" 처럼 **한두 줄로 명시**한다.
3. **기술 스택**: React, Spring Boot, FastAPI, CLIP, ChromaDB, Gemini, JWT, Redis 등 **실제 사용한 것만** 나열한다.
4. **규모**: "Frontend 6+ 페이지, Spring 7+ 도메인, FastAPI 4+ API" 처럼 **개수**를 적으면 설득력이 올라간다.

---

이 문서에서 자신이 한 항목만 골라서 [한 줄 요약]·[상세 문장]을 복사해 쓰면, "내가 한 부분"이 분명해져서 포트폴리오가 덜 약해 보입니다.
